<?php


/**
 * Skeleton subclass for representing a row from the 'manuscripts' table.
 *
 *
 *
 * This class was autogenerated by Propel 1.3.0-dev on:
 *
 * 11/01/08 09:07:52
 *
 * You should add additional methods to this class to meet the
 * application requirements.  This class will only be generated as
 * long as it does not already exist in the output directory.
 *
 * @package    abajour
 * @subpackage lib.model
 * @author     Vadim Valuev
 * @version    SVN: $Id: manuscript.php 186 2010-03-29 07:37:14Z я $
 */
class manuscript extends Basemanuscript {
	
	private $collauthors;
	private $collreviewers;
	private $acorresponding;
	private $lastreviewerCriteria;
	private $lastauthorCriteria;
	private $collkeywords;
	private $lastkeywordCriteria;

	/**
	 * Initializes internal state of manuscript object.
	 * @see        parent::__construct()
	 */
	
	public function __construct()
	{
		// Make sure that parent constructor is always invoked, since that
		// is where any default values for this object are set.
		parent::__construct();
	}
	public function __toString()
	{
		return $this->getTitle();
	}
	
	/**
	 * @return array Array of sfGuardUserProfile objects in chronological order
	 */
	public function getReviewers ($criteria = null, $con = null)
	{
	   /* @var $criteria Criteria */
	   if ($criteria === null) {
            $criteria = new Criteria(sfGuardUserProfilePeer::DATABASE_NAME);
        }
        elseif ($criteria instanceof Criteria)
        {
            $criteria = clone $criteria;
        }
        if ($this->collreviewers === null) {
            if ($this->isNew()) {
               $this->collreviewers = array();
            } else {

                $criteria->add(reviewPeer::MANUSCRIPT_ID, $this->id);

//                sfGuardUserProfilePeer::addSelectColumns($criteria);
                $criteria->addJoin(sfGuardUserProfilePeer::USER_ID, reviewPeer::USER_ID);
                $criteria->addAscendingOrderByColumn(reviewPeer::SUBMITTED);
                $this->collreviewers = sfGuardUserProfilePeer::doSelect($criteria, $con);
            }
        } else {
                        if (!$this->isNew()) {
                                                

                $criteria->add(reviewPeer::MANUSCRIPT_ID, $this->id);
                $criteria->addJoin(sfGuardUserProfilePeer::USER_ID, reviewPeer::USER_ID);
                $criteria->addAscendingOrderByColumn(reviewPeer::SUBMITTED);
//                reviewPeer::addSelectColumns($criteria);
                if (!isset($this->lastreviewerCriteria) || !$this->lastreviewerCriteria->equals($criteria)) {
                    $this->collreviewers = sfGuardUserProfilePeer::doSelect($criteria, $con);
                }
            }
        }
        $this->lastreviewerCriteria = $criteria;
        return $this->collreviewers;
	}
	
	
	public function getAuthors($criteria = null, $con = null)
	{
	   if ($criteria === null) {
            $criteria = new Criteria(sfGuardUserProfilePeer::DATABASE_NAME);
        }
	    elseif ($criteria instanceof Criteria)
        {
            $criteria = clone $criteria;
        }
        if ($this->collauthors === null) {
            if ($this->isNew()) {
               $this->collauthors = array();
            } else {

                $criteria->add(userManuscriptRefPeer::MANUSCRIPT_ID, $this->id);
                $criteria->addJoin(sfGuardUserProfilePeer::USER_ID, userManuscriptRefPeer::USER_ID);
                $xrefs = userManuscriptRefPeer::doSelectJoinsfGuardUserProfile($criteria, $con);
                foreach ($xrefs as $xref)
                {
                    /* @var $xref userManuscriptRef */
                    $this->collauthors[$xref->getAuthorOrder()] = $xref->getsfGuardUserProfile();
                    if ($xref->getIsCorrespondingAuthor()) $this->acorresponding = $xref->getsfGuardUserProfile();
                    
                }
             }
        } else {
                        if (!$this->isNew()) {
                                                

                $criteria->add(userManuscriptRefPeer::MANUSCRIPT_ID, $this->id);
                $criteria->addJoin(sfGuardUserProfilePeer::USER_ID, userManuscriptRefPeer::USER_ID);
                if (!isset($this->lastauthorCriteria) || !$this->lastauthorCriteria->equals($criteria)) {
                $xrefs = userManuscriptRefPeer::doSelectJoinsfGuardUserProfile($criteria, $con);
                foreach ($xrefs as $xref)
                {
                    /* @var $xref userManuscriptRef */
                    $this->collauthors[$xref->getAuthorOrder()] = $xref->getsfGuardUserProfile();
                    if ($xref->getIsCorrespondingAuthor()) $this->acorresponding = $xref->getsfGuardUserProfile();
                }
                }
            }
        }
        $this->lastauthorCriteria = $criteria;
        return $this->collauthors;
	}
	
    /**
	 * @return sfGuardUserProfile
	 */
	public function getCorrespondingAuthor()
	{
		if (!$this->isNew() && is_null($this->acorresponding))
		{
		  $c = new Criteria();
		  $c->add(userManuscriptRefPeer::MANUSCRIPT_ID, $this->getId());
		  $c->add(userManuscriptRefPeer::IS_CORRESPONDING_AUTHOR, true);
		  $xref = userManuscriptRefPeer::doSelectOne($c);
		  /* @var $xref userManuscriptRef */
		  if ($xref) $this->acorresponding = $xref->getsfGuardUserProfile();
		}
		return $this->acorresponding;
	}
	
	public function getStatusString()
	{
		return manuscriptPeer::statusString($this->getStatus());
	}
	
	public function getSubmittedDatetime($format = null)
	{
		$datetime = null;
		foreach ($this->getactionsByDate() as $action)
		{
			/* @var $action action */
			if ($action->getStatusAfter() == manuscriptPeer::SUBMITTED)
			{
				$datetime = $action->getDatetime(null);
			}
		}
		if (is_null($datetime)) $datetime = new DateTime('1980-00-00');
		if ($format == null) return $datetime;
		else return date_format($datetime, $format);
	}
	
	public function getAcceptedReviewDatetime($format = null)
	{
		$datetime = null;
		foreach ($this->getactions() as $action)
		{
			/* @var $action action */
			if ($action->getStatusAfter() == manuscriptPeer::ACCEPTED_REVIEW)
			{
				$datetime = $action->getDatetime(null);
			}
		}
		if ($format == null) return $datetime;
		else return date_format($datetime, $format);
	}
	
    public function getSentReviewDatetime($format = null)
    {
        $datetime = new DateTime('1950-01-01 00:00:00');
        foreach ($this->getactions() as $action)
        {
            /* @var $action action */
            if ($action->getStatusAfter() == manuscriptPeer::UNDER_REVIEW )
            {
                $datetime = $action->getDatetime(null);
                break;
            }
        }
        if ($format == null) return $datetime;
        else return date_format($datetime, $format);
    }
    
    public function getSubmittedReviewDatetime($reviewer_id, $format = 'Y-m-d H:i:s')
    {
    	$c = new Criteria();
    	$c->add(reviewPeer::USER_ID, $reviewer_id);
    	$c->add(reviewPeer::OUTCOME, reviewPeer::UNREVIEWED, Criteria::NOT_EQUAL);
    	$reviews = $this->getreviews($c);
    	if (count($reviews) > 1) throw new sfException('duplicate reviews');
    	if (count($reviews) == 0) return null;
    	$review = $reviews[0];
        return $review->getSubmitted($format);
    }
    
    public function getLastFilename ()
    {
        $file = array_pop($this->_getFilesNumber());
        return $file['filename'];
    }
    
    public function getLastExtraFilename ()
    {
        $file = array_pop($this->_getFilesNumber('extra'));
        return $file['filename'];
    }
	
    /**
     * @return array of arrays ('date'=>, 'size'=>, 'filenename'=>)
     */
    public function getFilesNumber($depth=1)
    {
    	return $this->_getFilesNumber('', $depth);
    }
    
 /**
* @return array (action_id=>array(date, size, filepath)
*/
    public function getExtraFilesNumber($depth=1)
    {
        return $this->_getFilesNumber('extra', $depth);
    }
    
    private function _getFilesNumber ($prefix='', $depth=1)
    {
    	$return_files = array();
        $filepattern = ($prefix?$prefix.'_':'').$this->getId().'_';
        $files = sfFinder::type('file')->name($filepattern.'*')->maxdepth($depth)->in(sfConfig::get('sf_upload_dir'));
        foreach ($files as $filename)
        {
            $action_id = intval(str_replace($filepattern, '', basename($filename)));
            $datetime = actionPeer::retrieveByPK($action_id)->getDatetime('U');
            $info = stat($filename);
            $return_files[$action_id]= array('date'=>$datetime, 'size'=>$info['size'], 'filename'=>$filename);
        }
        ksort($return_files);
        return $return_files;
    }
    
    
	public function isAuthor (sfGuardUserProfile $v)
	{
		if (in_array($v, $this->getAuthors())) return true;
		else return false;
	}
	
    public function isReviewer (sfGuardUserProfile $v)
    {
        if (in_array($v, $this->getReviewers())) return true;
        else return false;
    }
    
    public function isCorresponding (sfGuardUserProfile $v)
    {
    	if (!$this->getCorrespondingAuthor()) return false;
    	elseif ($this->getCorrespondingAuthor()->getId() == $v->getId()) return true;
    	else return false;
    }
    
    public function addAuthor ($v, $i, $isCorresponding = false)
    {
    	$userManuscriptRef = userManuscriptRefPeer::retrieveByPK($v->getId(), $this->getId());
    	if (is_null($userManuscriptRef))
    	{
    		$userManuscriptRef = new userManuscriptRef();
    		$userManuscriptRef->setmanuscript($this);
    	}
    	$userManuscriptRef->setsfGuardUserProfile($v);
    	$userManuscriptRef->setAuthorOrder($i);
    	$userManuscriptRef->setIsCorrespondingAuthor($isCorresponding);
    	$this->collauthors[$i] = $v;
    	if ($isCorresponding) $this->acorresponding = $v;
    }
    
    public function setSubmittedDatetime ($v)
    {
    	$submit_action = null;
        foreach ($this->getactions() as $action)
        {
            /* @var $action action */
            if ($action->getStatusAfter() == manuscriptPeer::SUBMITTED)
            {
                $submit_action = $action; break;
            }
        }
        if (is_null($submit_action))
        {
        	$submit_action = new action();
        	$submit_action->setStatusAfter(manuscriptPeer::SUBMITTED);
        	$submit_action->setStatusBefore(manuscriptPeer::CREATED);
            $submit_action->setmanuscript($this);
        }
        $submit_action->setDatetime($v);
    }
    
    public function isStatusChangeable()
    {
    	switch ($this->getStatus())
    	{
    		case manuscriptPeer::REJECT: case manuscriptPeer::PUBLISHED: case manuscriptPeer::ACCEPTED_PUBL:
    			return false;
    		default: return true;
    		
    	}
    }

    public function getactionsByDate ()
    {
    	$c = new Criteria();
    	$c->addAscendingOrderByColumn(actionPeer::DATETIME);
    	return $this->getactions($c);
    }

    public function setStatus ($v, $time = null)
    {
    	if ($v !== null) {
            $v = (int) $v;
        }
        
        $a = new action();
        $this->addaction($a);
        $a->setStatusBefore($this->status);
        parent::setStatus($v);
        $a->setStatusAfter($this->status);
        if ( !is_null($time)) $a->setDatetime($time);
        return $this;
    }
    
    /**
     * @var $v reviewer id
     */
    public function addReviewerId ($v)
    {
    	if ($r = reviewPeer::retrieveByPK($v, $this->id)) $this->addreview($r);
    	else
    	{
    		$r = new review();
    		$r->setUserId($v)->setmanuscript($this);
    	}
    	return $this;
    }

    public function getLastReview()
    {
        $c = new Criteria();
     	$c->add(reviewPeer::OUTCOME, reviewPeer::UNREVIEWED, Criteria::NOT_EQUAL);
     	$c->addDescendingOrderByColumn(reviewPeer::SUBMITTED);
     	$c->setLimit(1);
     	$r = $this->getreviews($c);
     	if (!empty($r)) return $r[0];
     	else return null;
    }
    
    public function flush()
    {
    	$actions = $this->getactions();
    	foreach ($actions as $action) $action->delete();
    	$this->status = manuscriptPeer::CREATED;
    	$this->save();
    }

    public function getCurrentReviewer()
    {
    	$c = new Criteria();
    	$c->add(reviewPeer::OUTCOME, reviewPeer::UNREVIEWED);
    	$c->addOr(reviewPeer::OUTCOME, reviewPeer::REVISE);
        $c->addOr(reviewPeer::OUTCOME, reviewPeer::ACCEPT_COMMENT);
        $c->addOr(reviewPeer::OUTCOME, reviewPeer::ACCEPT_SMALL);
        $c->add(reviewPeer::MANUSCRIPT_ID, $this->id);
        $c->addJoin(sfGuardUserProfilePeer::USER_ID, reviewPeer::USER_ID);
        $c->addDescendingOrderByColumn(reviewPeer::SUBMITTED);
//    	$r = $this->getReviewers($c);
//    	if (count($r)>1) throw new sfException('Duplicate reviewers for manuscript');
//    	if (empty($r)) return null;
//    	else return $r[0];
        return sfGuardUserProfilePeer::doSelectOne($c);
    }

    
    public function generateFilename ($action_id = null)
    {
    	return $this->_generateFilename($action_id);
    }

    
    public function generateFilenameExtra($action_id = null)
    {
    	return $this->_generateFilename($action_id, 'extra_');
    }
    
    private function _generateFilename ($action_id = null, $prefix = '')
    {
    	if ($action_id instanceof action ) $action_id = $action_id->getId();
        if ($action_id === null)
        {
           if (empty($this->collactions)) throw new sfException('Filename generation supposed to be called when new action is created');
           if (count($this->collactions)>1) throw new sfException('Filename generation supposed to be called only upon submission');
           $action_id = $this->collactions[0]->getId();
        }
        $filename = $prefix.$this->getId().'_'.$action_id;
        return $filename;
    }
    
    public function getKeywords($criteria = null, $con = null)
    {
     /* @var $criteria Criteria */
       if ($criteria === null) {
            $criteria = new Criteria(sfGuardUserProfilePeer::DATABASE_NAME);
        }
        elseif ($criteria instanceof Criteria)
        {
            $criteria = clone $criteria;
        }
        if ($this->collkeywords === null) {
            if ($this->isNew()) {
               $this->collkeywords = array();
            } else {
                $keys = $this->getKeywordManuscriptRefsJoinKeyword($criteria, $con);
                $this->collkeywords = array();
                foreach ($keys as $key)
                {
                	$this->collkeywords[] = $key->getKeyword();
                }
            }
        }
        else
        {
            if (!$this->isNew())
            {
                if (!isset($this->lastkeywordCriteria) || !$this->lastkeywordCriteria->equals($criteria))
                {
                    $keys = $this->getKeywordManuscriptRefsJoinKeyword($criteria, $con);
                    $this->collkeywords = array();
                    foreach ($keys as $key)
                    {
                        $this->collkeywords[] = $key->getKeyword();
                    }
                }
            }
        }
        $this->lastkeywordCriteria = $criteria;
        return $this->collkeywords;
    }

    /**
     * @return array filenames
     */
    public function getReviewFilenames ()
    {
    	$filename =  'r_'.$this->getId();
        $files = sfFinder::type('file')->name($filename.'*')->maxdepth(1)->in(sfConfig::get('sf_upload_dir'));
        return $files;
    }

    public function getTitle() {
    	$raw = parent::getTitle();
    	return strip_tags($raw, '<sub><sup><i>');
    }

    public function delete(PropelPDO $con = null) {
      $man_files = $this->getFilesNumber();
      $files = array();
      foreach ($man_files as $action=>$data) {
        $files[] = $data['filename'];
      }
      //убрать дополнительные файлы
      $extra_files = $this->getExtraFilesNumber();
      foreach ($extra_files as $action=>$data) {
        $files[] = $data['filename'];
      }
      $filesystem = new sfFilesystem();
      $filesystem->remove($files);
      //файлы рецензии
      $review_files = $this->getReviewFilenames();
      $filesystem->remove($review_files);
      //затем саму статью
      parent::delete($con);
    }
} // manuscript
